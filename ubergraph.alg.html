<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>ubergraph.alg documentation</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Ubergraph</span> <span class="project-version">0.5.0</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>ubergraph</span></div></div></li><li class="depth-2 branch current"><a href="ubergraph.alg.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>alg</span></div></a></li><li class="depth-2"><a href="ubergraph.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="ubergraph.alg.html#var-*auto-bellman-ford*"><div class="inner"><span>*auto-bellman-ford*</span></div></a></li><li class="depth-1"><a href="ubergraph.alg.html#var-bellman-ford"><div class="inner"><span>bellman-ford</span></div></a></li><li class="depth-1"><a href="ubergraph.alg.html#var-bf-span"><div class="inner"><span>bf-span</span></div></a></li><li class="depth-1"><a href="ubergraph.alg.html#var-bipartite-color"><div class="inner"><span>bipartite-color</span></div></a></li><li class="depth-1"><a href="ubergraph.alg.html#var-bipartite-sets"><div class="inner"><span>bipartite-sets</span></div></a></li><li class="depth-1"><a href="ubergraph.alg.html#var-bipartite.3F"><div class="inner"><span>bipartite?</span></div></a></li><li class="depth-1"><a href="ubergraph.alg.html#var-connect"><div class="inner"><span>connect</span></div></a></li><li class="depth-1"><a href="ubergraph.alg.html#var-connected-components"><div class="inner"><span>connected-components</span></div></a></li><li class="depth-1"><a href="ubergraph.alg.html#var-connected.3F"><div class="inner"><span>connected?</span></div></a></li><li class="depth-1"><a href="ubergraph.alg.html#var-cost-of-path"><div class="inner"><span>cost-of-path</span></div></a></li><li class="depth-1"><a href="ubergraph.alg.html#var-dag.3F"><div class="inner"><span>dag?</span></div></a></li><li class="depth-1"><a href="ubergraph.alg.html#var-distinct-edges"><div class="inner"><span>distinct-edges</span></div></a></li><li class="depth-1"><a href="ubergraph.alg.html#var-edges-in-path"><div class="inner"><span>edges-in-path</span></div></a></li><li class="depth-1"><a href="ubergraph.alg.html#var-end-of-path"><div class="inner"><span>end-of-path</span></div></a></li><li class="depth-1"><a href="ubergraph.alg.html#var-loners"><div class="inner"><span>loners</span></div></a></li><li class="depth-1"><a href="ubergraph.alg.html#var-longest-shortest-path"><div class="inner"><span>longest-shortest-path</span></div></a></li><li class="depth-1"><a href="ubergraph.alg.html#var-nodes-in-path"><div class="inner"><span>nodes-in-path</span></div></a></li><li class="depth-1"><a href="ubergraph.alg.html#var-path-to"><div class="inner"><span>path-to</span></div></a></li><li class="depth-1"><a href="ubergraph.alg.html#var-post-traverse"><div class="inner"><span>post-traverse</span></div></a></li><li class="depth-1"><a href="ubergraph.alg.html#var-pprint-path"><div class="inner"><span>pprint-path</span></div></a></li><li class="depth-1"><a href="ubergraph.alg.html#var-pre-span"><div class="inner"><span>pre-span</span></div></a></li><li class="depth-1"><a href="ubergraph.alg.html#var-pre-traverse"><div class="inner"><span>pre-traverse</span></div></a></li><li class="depth-1"><a href="ubergraph.alg.html#var-scc"><div class="inner"><span>scc</span></div></a></li><li class="depth-1"><a href="ubergraph.alg.html#var-shortest-path"><div class="inner"><span>shortest-path</span></div></a></li><li class="depth-1"><a href="ubergraph.alg.html#var-start-of-path"><div class="inner"><span>start-of-path</span></div></a></li><li class="depth-1"><a href="ubergraph.alg.html#var-strongly-connected.3F"><div class="inner"><span>strongly-connected?</span></div></a></li><li class="depth-1"><a href="ubergraph.alg.html#var-topsort"><div class="inner"><span>topsort</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">ubergraph.alg</h1><div class="doc"><pre class="plaintext">Contains algorithms that operate on Ubergraphs, and all the functions associated with paths
</pre></div><div class="public anchor" id="var-*auto-bellman-ford*"><h3>*auto-bellman-ford*</h3><h4 class="dynamic">dynamic</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Bind this dynamic variable to false if you prefer for shortest-path to throw an error, if negative cost edge is found.
</pre></div><div class="src-link"><a href="http://github.com/Engelberg/ubergraph/tree/master/src/ubergraph/alg.clj#L360">view source</a></div></div><div class="public anchor" id="var-bellman-ford"><h3>bellman-ford</h3><div class="usage"><code>(bellman-ford g start-node cost-attr)</code><code>(bellman-ford g search-specification)</code></div><div class="doc"><pre class="plaintext">Given an ubergraph g, and one or more start nodes,
the Bellman-Ford algorithm produces an implementation of the
IAllPathsFromSource protocol if no negative-weight cycle that is 
reachable from the source exits, and false otherwise, indicating 
that no solution exists.

bellman-ford is very similar to shortest-path.  It is less efficient,
but it correctly handles graphs with negative edges.  If you know you
have edges with negative costs, use bellman-ford.  If you are unsure
whether your graph has negative costs, or don't understand when and
why you'd want to use bellman-ford, just use shortest-path and it
will make the decision for you, calling this function if necessary. 

Takes a search-specification map which must contain:
Either :start-node (single node) or :start-nodes (collection)

Map may contain the following entries:
Either :end-node (single node) or :end-nodes (collection) or :end-node? (predicate function) 
:cost-fn - A function that takes an edge as an input and returns a cost 
          (defaults to weight, or 1 if no weight is present)
:cost-attr - Alternatively, can specify an edge attribute to use as the cost
:node-filter - A predicate function that takes a node and returns true or false.
          If specified, only nodes that pass this node-filter test will be considered in the search.
:edge-filter - A predicate function that takes an edge and returns true or false.
          If specified, only edges that pass this edge-filter test will be considered in the search.

Map may contain the following additional entries if a traversal sequence is desired:
:traverse true - Changes output to be a sequence of paths in order encountered.
:min-cost - Filters traversal sequence, only applies if :traverse is set to true
:max-cost - Filters traversal sequence, only applies if :traverse is set to true

bellman-ford has specific arity for the most common combination:
(bellman-ford g start-node cost-attr)</pre></div><div class="src-link"><a href="http://github.com/Engelberg/ubergraph/tree/master/src/ubergraph/alg.clj#L539">view source</a></div></div><div class="public anchor" id="var-bf-span"><h3>bf-span</h3><div class="usage"><code>(bf-span g)</code><code>(bf-span g start)</code></div><div class="doc"><pre class="plaintext">Returns a breadth-first spanning tree of the form {node [successors]}
</pre></div></div><div class="public anchor" id="var-bipartite-color"><h3>bipartite-color</h3><div class="usage"><code>(bipartite-color g)</code></div><div class="doc"><pre class="plaintext">Attempts a two-coloring of graph g. When successful, returns a map of
nodes to colors (1 or 0). Otherwise, returns nil.</pre></div></div><div class="public anchor" id="var-bipartite-sets"><h3>bipartite-sets</h3><div class="usage"><code>(bipartite-sets g)</code></div><div class="doc"><pre class="plaintext">Returns two sets of nodes, one for each color of the bipartite coloring,
or nil if g is not bipartite</pre></div></div><div class="public anchor" id="var-bipartite.3F"><h3>bipartite?</h3><div class="usage"><code>(bipartite? g)</code></div><div class="doc"><pre class="plaintext">Returns true if g is bipartite
</pre></div></div><div class="public anchor" id="var-connect"><h3>connect</h3><div class="usage"><code>(connect g)</code></div><div class="doc"><pre class="plaintext">Returns graph g with all connected components connected to each other
</pre></div></div><div class="public anchor" id="var-connected-components"><h3>connected-components</h3><div class="usage"><code>(connected-components g)</code></div><div class="doc"><pre class="plaintext">Returns the connected components of graph g as a vector of vectors. If g
is directed, returns the weakly-connected components.</pre></div></div><div class="public anchor" id="var-connected.3F"><h3>connected?</h3><div class="usage"><code>(connected? g)</code></div><div class="doc"><pre class="plaintext">Returns true if g is connected
</pre></div></div><div class="public anchor" id="var-cost-of-path"><h3>cost-of-path</h3><div class="usage"><code>(cost-of-path path)</code></div><div class="doc"><pre class="plaintext">Returns the cost of the path with respect to the property that was minimized
in the search that produced this path.</pre></div><div class="src-link"><a href="http://github.com/Engelberg/ubergraph/tree/master/src/ubergraph/alg.clj#L15">view source</a></div></div><div class="public anchor" id="var-dag.3F"><h3>dag?</h3><div class="usage"><code>(dag? g)</code></div><div class="doc"><pre class="plaintext">Returns true if g is a directed acyclic graph
</pre></div></div><div class="public anchor" id="var-distinct-edges"><h3>distinct-edges</h3><div class="usage"><code>(distinct-edges g)</code></div><div class="doc"><pre class="plaintext">Distinct edges of g.
</pre></div><div class="src-link"><a href="http://github.com/Engelberg/ubergraph/tree/master/src/ubergraph/alg.clj#L471">view source</a></div></div><div class="public anchor" id="var-edges-in-path"><h3>edges-in-path</h3><div class="usage"><code>(edges-in-path path)</code></div><div class="doc"><pre class="plaintext">A list of edges comprising the path
</pre></div><div class="src-link"><a href="http://github.com/Engelberg/ubergraph/tree/master/src/ubergraph/alg.clj#L15">view source</a></div></div><div class="public anchor" id="var-end-of-path"><h3>end-of-path</h3><div class="usage"><code>(end-of-path path)</code></div><div class="doc"><pre class="plaintext">Returns the last node in the path
</pre></div><div class="src-link"><a href="http://github.com/Engelberg/ubergraph/tree/master/src/ubergraph/alg.clj#L15">view source</a></div></div><div class="public anchor" id="var-loners"><h3>loners</h3><div class="usage"><code>(loners g)</code></div><div class="doc"><pre class="plaintext">Return nodes with no connections to other nodes (i.e., isolated nodes)
</pre></div><div class="src-link"><a href="http://github.com/Engelberg/ubergraph/tree/master/src/ubergraph/alg.clj#L463">view source</a></div></div><div class="public anchor" id="var-longest-shortest-path"><h3>longest-shortest-path</h3><div class="usage"><code>(longest-shortest-path g start)</code></div><div class="doc"><pre class="plaintext">The longest shortest-path starting from start
</pre></div><div class="src-link"><a href="http://github.com/Engelberg/ubergraph/tree/master/src/ubergraph/alg.clj#L480">view source</a></div></div><div class="public anchor" id="var-nodes-in-path"><h3>nodes-in-path</h3><div class="usage"><code>(nodes-in-path path)</code></div><div class="doc"><pre class="plaintext">A list of nodes comprising the path
</pre></div><div class="src-link"><a href="http://github.com/Engelberg/ubergraph/tree/master/src/ubergraph/alg.clj#L15">view source</a></div></div><div class="public anchor" id="var-path-to"><h3>path-to</h3><div class="usage"><code>(path-to paths dest)</code></div><div class="doc"><pre class="plaintext">The shortest path to dest
</pre></div><div class="src-link"><a href="http://github.com/Engelberg/ubergraph/tree/master/src/ubergraph/alg.clj#L15">view source</a></div></div><div class="public anchor" id="var-post-traverse"><h3>post-traverse</h3><div class="usage"><code>(post-traverse g)</code><code>(post-traverse g start &amp; opts)</code></div><div class="doc"><pre class="plaintext">Traverses graph g depth-first, post-order from start. Returns a
vector of the nodes.</pre></div></div><div class="public anchor" id="var-pprint-path"><h3>pprint-path</h3><div class="usage"><code>(pprint-path p)</code><code>(pprint-path g p)</code></div><div class="doc"><pre class="plaintext">Prints a path's edges along with the edges' attribute maps. 
(pprint-path g p) will print the attribute maps currently stored in graph g for each edge in p.
(pprint-path p) will print the attribute maps associated with each edge in p at the time the path was generated.</pre></div><div class="src-link"><a href="http://github.com/Engelberg/ubergraph/tree/master/src/ubergraph/alg.clj#L97">view source</a></div></div><div class="public anchor" id="var-pre-span"><h3>pre-span</h3><div class="usage"><code>(pre-span g)</code><code>(pre-span g start)</code></div><div class="doc"><pre class="plaintext">Returns a depth-first spanning tree of the form {node [successors]}
</pre></div></div><div class="public anchor" id="var-pre-traverse"><h3>pre-traverse</h3><div class="usage"><code>(pre-traverse g)</code><code>(pre-traverse g start)</code></div><div class="doc"><pre class="plaintext">Traverses graph g depth-first from start. Returns a lazy seq of nodes.
When no starting node is provided, traverses the entire graph, connected
or not.</pre></div></div><div class="public anchor" id="var-scc"><h3>scc</h3><div class="usage"><code>(scc g)</code></div><div class="doc"><pre class="plaintext">Returns the strongly-connected components of directed graph g as a vector of
vectors. Uses Kosaraju's algorithm.</pre></div></div><div class="public anchor" id="var-shortest-path"><h3>shortest-path</h3><div class="usage"><code>(shortest-path g start-node end-node)</code><code>(shortest-path g start-node end-node cost-attr)</code><code>(shortest-path g search-specification)</code></div><div class="doc"><pre class="plaintext">Finds the shortest path in graph g. You must specify a start node or a collection
of start nodes from which to begin the search, however specifying an end node
is optional. If an end node condition is specified, this function will return an 
implementation of the IPath protocol, representing the shortest path. Otherwise, 
it will search out as far as it can go, and return an implementation of the 
IAllPathsFromSource protocol, which contains all the data needed to quickly find
the shortest path to a given destination (using IAllPathsFromSource's `path-to` 
protocol function).

If :traverse is set to true, then the function will instead return a lazy sequence
of the shortest paths from the start node(s) to each node in the graph in the order
the nodes are encountered by the search process.

Takes a search-specification map which must contain:
Either :start-node (single node) or :start-nodes (collection)

Map may contain the following entries:
Either :end-node (single node) or :end-nodes (collection) or :end-node? (predicate function) 
:cost-fn - A function that takes an edge as an input and returns a cost 
          (defaults to every edge having a cost of 1, i.e., breadth-first search if no cost-fn given)
:cost-attr - Alternatively, can specify an edge attribute to use as the cost
:heuristic-fn - A function that takes a node as an input and returns a
          lower-bound on the distance to a goal node, used to guide the search
          and make it more efficient.
:node-filter - A predicate function that takes a node and returns true or false.
          If specified, only nodes that pass this node-filter test will be considered in the search.
:edge-filter - A predicate function that takes an edge and returns true or false.
          If specified, only edges that pass this edge-filter test will be considered in the search.

Map may contain the following additional entries if a traversal sequence is desired:
:traverse true - Changes output to be a sequence of paths in order encountered.
:min-cost - Filters traversal sequence, only applies if :traverse is set to true
:max-cost - Filters traversal sequence, only applies if :traverse is set to true


shortest-path has specific arities for the two most common combinations:
(shortest-path g start-node end-node)
(shortest-path g start-node end-node cost-attr)</pre></div><div class="src-link"><a href="http://github.com/Engelberg/ubergraph/tree/master/src/ubergraph/alg.clj#L363">view source</a></div></div><div class="public anchor" id="var-start-of-path"><h3>start-of-path</h3><div class="usage"><code>(start-of-path path)</code></div><div class="doc"><pre class="plaintext">Returns the first node in the path
</pre></div><div class="src-link"><a href="http://github.com/Engelberg/ubergraph/tree/master/src/ubergraph/alg.clj#L15">view source</a></div></div><div class="public anchor" id="var-strongly-connected.3F"><h3>strongly-connected?</h3><div class="usage"><code>(strongly-connected? g)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-topsort"><h3>topsort</h3><div class="usage"><code>(topsort g)</code><code>(topsort g start)</code></div><div class="doc"><pre class="plaintext">Topological sort of a directed acyclic graph (DAG). Returns nil if
g contains any cycles.</pre></div></div></div></body></html>